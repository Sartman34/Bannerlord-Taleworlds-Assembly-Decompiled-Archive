using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.SaveSystem;

namespace TaleWorlds.Core;

public class WeaponDesign
{
	[SaveableField(10)]
	public readonly WeaponFlags WeaponFlags;

	[SaveableField(30)]
	private readonly WeaponDesignElement[] _usedPieces;

	[CachedData]
	private int _cachedHashedCodeInt;

	[CachedData]
	private string _hashedCode;

	[SaveableField(40)]
	private readonly float[] _piecePivotDistances;

	[SaveableField(60)]
	public readonly float CraftedWeaponLength;

	[SaveableField(70)]
	public readonly CraftingTemplate Template;

	[SaveableField(80)]
	public List<float> TopPivotOffsets;

	[SaveableField(90)]
	public List<float> BottomPivotOffsets;

	[SaveableField(100)]
	public readonly Vec3 HolsterShiftAmount;

	[SaveableProperty(21)]
	public TextObject WeaponName { get; private set; }

	public WeaponDesignElement[] UsedPieces => _usedPieces;

	public string HashedCode => _hashedCode;

	public float[] PiecePivotDistances => _piecePivotDistances;

	public float TotalLength => CraftedWeaponLength + HandToBottomLength;

	[SaveableProperty(50)]
	public float HandToBottomLength { get; private set; }

	public float BottomPivotOffset => BottomPivotOffsets[BottomPivotOffsets.Count - 1];

	internal static void AutoGeneratedStaticCollectObjectsWeaponDesign(object o, List<object> collectedObjects)
	{
		((WeaponDesign)o).AutoGeneratedInstanceCollectObjects(collectedObjects);
	}

	protected virtual void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
	{
		collectedObjects.Add(Template);
		collectedObjects.Add(TopPivotOffsets);
		collectedObjects.Add(BottomPivotOffsets);
		collectedObjects.Add(_usedPieces);
		collectedObjects.Add(_piecePivotDistances);
		collectedObjects.Add(WeaponName);
	}

	internal static object AutoGeneratedGetMemberValueWeaponName(object o)
	{
		return ((WeaponDesign)o).WeaponName;
	}

	internal static object AutoGeneratedGetMemberValueHandToBottomLength(object o)
	{
		return ((WeaponDesign)o).HandToBottomLength;
	}

	internal static object AutoGeneratedGetMemberValueWeaponFlags(object o)
	{
		return ((WeaponDesign)o).WeaponFlags;
	}

	internal static object AutoGeneratedGetMemberValueCraftedWeaponLength(object o)
	{
		return ((WeaponDesign)o).CraftedWeaponLength;
	}

	internal static object AutoGeneratedGetMemberValueTemplate(object o)
	{
		return ((WeaponDesign)o).Template;
	}

	internal static object AutoGeneratedGetMemberValueTopPivotOffsets(object o)
	{
		return ((WeaponDesign)o).TopPivotOffsets;
	}

	internal static object AutoGeneratedGetMemberValueBottomPivotOffsets(object o)
	{
		return ((WeaponDesign)o).BottomPivotOffsets;
	}

	internal static object AutoGeneratedGetMemberValueHolsterShiftAmount(object o)
	{
		return ((WeaponDesign)o).HolsterShiftAmount;
	}

	internal static object AutoGeneratedGetMemberValue_usedPieces(object o)
	{
		return ((WeaponDesign)o)._usedPieces;
	}

	internal static object AutoGeneratedGetMemberValue_piecePivotDistances(object o)
	{
		return ((WeaponDesign)o)._piecePivotDistances;
	}

	public WeaponDesign(CraftingTemplate template, TextObject weaponName, WeaponDesignElement[] usedPieces)
	{
		Template = template;
		_usedPieces = usedPieces.ToArray();
		WeaponName = weaponName;
		_piecePivotDistances = new float[usedPieces.Length];
		CalculatePivotDistances();
		CraftedWeaponLength = CalculateWeaponLength();
		HolsterShiftAmount = CalculateHolsterShiftAmount();
		foreach (WeaponDesignElement weaponDesignElement in usedPieces)
		{
			WeaponFlags |= weaponDesignElement.CraftingPiece.AdditionalWeaponFlags;
		}
		BuildHashedCode();
	}

	[LoadInitializationCallback]
	private void OnLoad()
	{
		BuildHashedCode();
	}

	public void SetWeaponName(TextObject name)
	{
		WeaponName = name;
	}

	private void CalculatePivotDistances()
	{
		float num = 0f;
		float num2 = 0f;
		PieceData[] buildOrders = Template.BuildOrders;
		for (int i = 0; i < buildOrders.Length; i++)
		{
			PieceData pieceData = buildOrders[i];
			WeaponDesignElement weaponDesignElement = UsedPieces[(int)pieceData.PieceType];
			if (weaponDesignElement == null || !weaponDesignElement.IsValid)
			{
				_piecePivotDistances[(int)pieceData.PieceType] = float.NaN;
				continue;
			}
			int num3 = MathF.Sign(pieceData.Order);
			if (num3 == 0)
			{
				num2 += weaponDesignElement.ScaledPieceOffset;
				num -= weaponDesignElement.ScaledPieceOffset;
			}
			else if (num3 < 0)
			{
				num += weaponDesignElement.ScaledDistanceToNextPiece;
				num += weaponDesignElement.ScaledPieceOffset;
				num -= weaponDesignElement.ScaledNextPieceOffset;
			}
			else if (num3 > 0)
			{
				num2 += weaponDesignElement.ScaledDistanceToPreviousPiece;
				num2 += weaponDesignElement.ScaledPieceOffset;
				num2 -= weaponDesignElement.ScaledPreviousPieceOffset;
			}
			_piecePivotDistances[(int)pieceData.PieceType] = (float)num3 * ((num3 < 0) ? num : num2) + ((num3 == 0) ? weaponDesignElement.ScaledPieceOffset : 0f);
			AddTopPivotOffset(num2);
			AddBottomPivotOffset(num);
			if (num3 == 0)
			{
				num += weaponDesignElement.ScaledDistanceToPreviousPiece - weaponDesignElement.ScaledPreviousPieceOffset;
				num2 += weaponDesignElement.ScaledDistanceToNextPiece - weaponDesignElement.ScaledNextPieceOffset;
			}
			if (num3 < 0)
			{
				num += weaponDesignElement.ScaledDistanceToPreviousPiece - weaponDesignElement.ScaledPreviousPieceOffset;
			}
			if (num3 > 0)
			{
				num2 += weaponDesignElement.ScaledDistanceToNextPiece - weaponDesignElement.ScaledNextPieceOffset;
			}
		}
		AddTopPivotOffset(num2);
		AddBottomPivotOffset(num);
		HandToBottomLength = num;
	}

	public override bool Equals(object obj)
	{
		if (obj == null)
		{
			return false;
		}
		if (!(obj is WeaponDesign weaponDesign))
		{
			return false;
		}
		if (HashedCode == weaponDesign.HashedCode)
		{
			return WeaponName == weaponDesign.WeaponName;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return _cachedHashedCodeInt;
	}

	public static bool operator ==(WeaponDesign x, WeaponDesign y)
	{
		bool flag = (object)x == null;
		bool flag2 = (object)y == null;
		if (flag && flag2)
		{
			return true;
		}
		if (!flag)
		{
			return x.Equals(y);
		}
		return false;
	}

	public static bool operator !=(WeaponDesign x, WeaponDesign y)
	{
		return !(x == y);
	}

	private void AddTopPivotOffset(float offset)
	{
		if (TopPivotOffsets == null)
		{
			TopPivotOffsets = new List<float>();
		}
		TopPivotOffsets.Add(offset);
	}

	private void AddBottomPivotOffset(float offset)
	{
		if (BottomPivotOffsets == null)
		{
			BottomPivotOffsets = new List<float>();
		}
		BottomPivotOffsets.Add(offset);
	}

	private Vec3 CalculateHolsterShiftAmount()
	{
		WeaponDesignElement weaponDesignElement = UsedPieces[2];
		Vec3 result = (Template.ItemHolsterPositionShift + weaponDesignElement.CraftingPiece.ItemHolsterPosShift) * weaponDesignElement.ScaleFactor;
		if (UsedPieces[1] != null)
		{
			result += Vec3.Up * UsedPieces[1].ScaledLength;
		}
		return result;
	}

	private float CalculateWeaponLength()
	{
		int num = 0;
		float a = _piecePivotDistances[num] + _usedPieces[num].ScaledDistanceToNextPiece;
		float num2 = 0f;
		WeaponDesignElement[] usedPieces = _usedPieces;
		foreach (WeaponDesignElement weaponDesignElement in usedPieces)
		{
			if (weaponDesignElement.IsValid && weaponDesignElement.ScaledDistanceToNextPiece > num2)
			{
				float scaledPieceOffset = weaponDesignElement.ScaledPieceOffset;
				num2 = weaponDesignElement.ScaledDistanceToNextPiece + scaledPieceOffset;
			}
		}
		return MathF.Max(a, num2);
	}

	private void BuildHashedCode()
	{
		string text = "";
		WeaponDesignElement[] usedPieces = UsedPieces;
		foreach (WeaponDesignElement weaponDesignElement in usedPieces)
		{
			text = ((!weaponDesignElement.IsValid) ? (text + "invalid_piece;") : (text + weaponDesignElement.CraftingPiece.StringId + ";" + weaponDesignElement.ScalePercentage + ";"));
		}
		text += Template.StringId;
		text += WeaponName;
		_hashedCode = Common.CalculateMD5Hash(text);
		_cachedHashedCodeInt = Common.GetDJB2(_hashedCode);
	}
}
