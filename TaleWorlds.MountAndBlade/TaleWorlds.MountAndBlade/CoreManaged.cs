using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using TaleWorlds.DotNet;
using TaleWorlds.Library;

namespace TaleWorlds.MountAndBlade;

public class CoreManaged : IManagedComponent
{
	private static CoreManaged _instance;

	private static ICallbackManager _callbackManager;

	private static readonly Dictionary<int, IntPtr> _engineApiPointers = new Dictionary<int, IntPtr>();

	private static Delegate _passManagedCoreCallbackMethodPointersMono = null;

	public string ManagedCallbacksDll => ManagedDllFolder.Name + "TaleWorlds.MountAndBlade.AutoGenerated.dll";

	public CoreManaged()
	{
		_instance = this;
	}

	[MBCallback]
	public static void Start()
	{
		Managed.Start(new IManagedComponent[0]);
	}

	void IManagedComponent.OnStart()
	{
		Debug.DebugManager = new MBDebugManager();
		Dictionary<string, Type> dictionary = new Dictionary<string, Type>();
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		foreach (Assembly moduleAssembly in assemblies)
		{
			Dictionary<string, Type> second = CollectModuleAssemblyTypes(moduleAssembly);
			dictionary = dictionary.Union(second).ToDictionary((KeyValuePair<string, Type> k) => k.Key, (KeyValuePair<string, Type> v) => v.Value);
		}
		Managed.InitializeTypes(dictionary);
	}

	private Dictionary<string, Type> CollectModuleAssemblyTypes(Assembly moduleAssembly)
	{
		Dictionary<string, Type> dictionary = new Dictionary<string, Type>();
		try
		{
			Type[] types = moduleAssembly.GetTypes();
			foreach (Type type in types)
			{
				if (typeof(ManagedObject).IsAssignableFrom(type) || typeof(DotNetObject).IsAssignableFrom(type))
				{
					dictionary.Add(type.Name, type);
				}
			}
		}
		catch (Exception)
		{
			dictionary.Clear();
		}
		return dictionary;
	}

	[MBCallback]
	internal static void OnLoadCommonFinished()
	{
		FaceGen.CreateInstance();
	}

	private void OnInitialize()
	{
		List<Type> typesSafe = AssemblyLoader.LoadFrom(ManagedCallbacksDll).GetTypesSafe();
		Type type = null;
		foreach (Type item in typesSafe)
		{
			if (item.GetInterfaces().Contains(typeof(ICallbackManager)))
			{
				type = item;
				break;
			}
		}
		_callbackManager = type.GetConstructor(new Type[0]).Invoke(new object[0]) as ICallbackManager;
		_callbackManager.Initialize();
		Delegate[] delegates = _callbackManager.GetDelegates();
		for (int i = 0; i < delegates.Length; i++)
		{
			try
			{
				PassManagedCoreCallbackMethodPointers(delegates[i]);
			}
			catch (Exception ex)
			{
				PassManagedCoreCallbackMethodPointers(null);
				Console.WriteLine(string.Concat(ex, " ", i));
			}
		}
		MBAPI.SetObjects(_callbackManager.GetScriptingInterfaceObjects());
		Module.CreateModule();
	}

	void IManagedComponent.OnCustomCallbackMethodPassed(string name, Delegate method)
	{
		if (name == "MBCore")
		{
			_passManagedCoreCallbackMethodPointersMono = method;
			OnInitialize();
		}
	}

	[MBCallback]
	internal static void Finalize()
	{
		Module.FinalizeCurrentModule();
		Common.MemoryCleanupGC();
	}

	void IManagedComponent.OnApplicationTick(float dt)
	{
		Module.CurrentModule.OnApplicationTick(dt);
	}

	[MBCallback]
	internal static void CheckSharedStructureSizes()
	{
		_callbackManager.CheckSharedStructureSizes();
	}

	[MBCallback]
	internal static void EngineApiMethodInterfaceInitializer(int id, IntPtr pointer)
	{
		_engineApiPointers.Add(id, pointer);
	}

	[MBCallback]
	internal static void FillEngineApiPointers()
	{
		foreach (KeyValuePair<int, IntPtr> engineApiPointer in _engineApiPointers)
		{
			try
			{
				_callbackManager.SetFunctionPointer(engineApiPointer.Key, engineApiPointer.Value);
			}
			catch (Exception ex)
			{
				Console.WriteLine("error: " + engineApiPointer.Key + " " + ex);
			}
		}
	}

	private static void PassManagedCoreCallbackMethodPointers(Delegate methodDelegate)
	{
		_passManagedCoreCallbackMethodPointersMono?.DynamicInvoke(methodDelegate);
	}
}
