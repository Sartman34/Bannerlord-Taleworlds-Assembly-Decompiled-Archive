using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using TaleWorlds.Library;

namespace TaleWorlds.DotNet;

public static class Managed
{
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	[MonoNativeFunctionWrapper]
	public delegate void PassManagedInitializeMethodPointerDelegate([MarshalAs(UnmanagedType.FunctionPtr)] Delegate initalizer);

	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	[MonoNativeFunctionWrapper]
	public delegate void PassManagedCallbackMethodPointersDelegate([MarshalAs(UnmanagedType.FunctionPtr)] Delegate methodDelegate);

	[MonoNativeFunctionWrapper]
	public delegate void InitializerDelegate(Delegate argument);

	public enum RglScriptFieldType
	{
		RglSftString,
		RglSftDouble,
		RglSftFloat,
		RglSftBool,
		RglSftInt,
		RglSftVec3,
		RglSftEntity,
		RglSftTexture,
		RglSftMesh,
		RglSftEnum,
		RglSftMaterial,
		RglSftButton,
		RglSftColor,
		RglSftMatrixFrame
	}

	private static List<IManagedComponent> _components;

	private static ICallbackManager _callbackManager;

	internal static string ReturnValueFromEngine;

	private static ManagedInitializeMethod _initializer;

	private static Dictionary<string, Type> _moduleTypes;

	private static Dictionary<int, IntPtr> _engineApiPointers;

	private static Dictionary<string, Dictionary<string, FieldInfo>> _fieldsOfScriptsCached;

	private static Dictionary<string, Dictionary<string, FieldInfo>> _editableFieldsOfScriptsCached;

	private static Dictionary<string, ConstructorInfo> _constructorsOfScriptsCached;

	private static Dictionary<string, Delegate> _constructorDelegatesOfScriptsCached;

	private static Dictionary<Type, Delegate> _constructorDelegatesOfWeakReferencesCached;

	private static Delegate PassManagedInitializeMethodPointerMono;

	private static Delegate PassManagedEngineCallbackMethodPointersMono;

	internal static bool Closing { get; private set; }

	internal static Dictionary<string, Type> ModuleTypes => _moduleTypes;

	internal static NativeTelemetryManager NativeTelemetryManager { get; private set; }

	public static string ManagedCallbacksDll => ManagedDllFolder.Name + "TaleWorlds.DotNet.AutoGenerated.dll";

	static Managed()
	{
		ReturnValueFromEngine = "";
		_engineApiPointers = new Dictionary<int, IntPtr>();
		_fieldsOfScriptsCached = new Dictionary<string, Dictionary<string, FieldInfo>>();
		_editableFieldsOfScriptsCached = new Dictionary<string, Dictionary<string, FieldInfo>>();
		_constructorsOfScriptsCached = new Dictionary<string, ConstructorInfo>();
		_constructorDelegatesOfScriptsCached = new Dictionary<string, Delegate>();
		_constructorDelegatesOfWeakReferencesCached = new Dictionary<Type, Delegate>();
		PassManagedInitializeMethodPointerMono = null;
		PassManagedEngineCallbackMethodPointersMono = null;
		_components = new List<IManagedComponent>();
		Closing = false;
		NativeTelemetryManager = new NativeTelemetryManager();
		TaleWorlds.Library.Debug.TelemetryManager = NativeTelemetryManager;
	}

	[LibraryCallback]
	internal static void SetLogsFolder(string logFolder)
	{
	}

	[LibraryCallback]
	public static string GetStackTraceStr(int skipCount = 0)
	{
		string text = new StackTrace(skipCount, fNeedFileInfo: true).ToString();
		text = text.Replace("\r", "");
		text = text.Replace("   ", "");
		if (text.Length >= 16)
		{
			return text;
		}
		return "";
	}

	[LibraryCallback]
	public static string GetStackTraceRaw(int skipCount = 0)
	{
		return GetStackTraceRaw(new StackTrace(0, fNeedFileInfo: false), skipCount);
	}

	public static string GetStackTraceRaw(StackTrace stack, int skipCount = 0)
	{
		MBStringBuilder mBStringBuilder = default(MBStringBuilder);
		mBStringBuilder.Initialize(16, "GetStackTraceRaw");
		for (int i = 0; i < stack.FrameCount; i++)
		{
			if (i >= skipCount)
			{
				string text = "unknown_module.dll";
				try
				{
					StackFrame frame = stack.GetFrame(i);
					MethodBase method = frame.GetMethod();
					text = method.Module.Assembly.Location;
					int iLOffset = frame.GetILOffset();
					int metadataToken = method.MetadataToken;
					mBStringBuilder.AppendLine(text + "@" + metadataToken + "@" + iLOffset);
				}
				catch
				{
					mBStringBuilder.AppendLine(text + "@-1@-1");
				}
			}
		}
		return mBStringBuilder.ToStringAndRelease();
	}

	[LibraryCallback]
	public static string GetModuleList()
	{
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		string text = "";
		Assembly[] array = assemblies;
		foreach (Assembly assembly in array)
		{
			try
			{
				text += assembly.Location;
				text += "\n";
			}
			catch
			{
			}
		}
		return text;
	}

	[LibraryCallback]
	public static void GetVersionInts(ref int major, ref int minor, ref int revision)
	{
		ApplicationVersion applicationVersion = ApplicationVersion.FromParametersFile();
		major = applicationVersion.Major;
		minor = applicationVersion.Minor;
		revision = applicationVersion.Revision;
	}

	[LibraryCallback]
	internal static DotNetObject CreateCustomParameterStringArray(int length)
	{
		return new CustomParameter<string[]>(new string[length]);
	}

	internal static DotNetObject AddCustomParameter<T>(T parameterData) where T : class
	{
		return new CustomParameter<T>(parameterData);
	}

	[LibraryCallback]
	internal static void GarbageCollect(bool forceTimer)
	{
		Common.MemoryCleanupGC(forceTimer);
	}

	[LibraryCallback]
	internal static void SetStringArrayValueAtIndex(string[] array, int index, string value)
	{
		array[index] = value;
	}

	[LibraryCallback]
	internal static string GetStringArrayValueAtIndex(string[] array, int index)
	{
		return array[index];
	}

	internal static void PassInitializationMethodPointersForMono(IntPtr a, IntPtr b)
	{
		PassManagedInitializeMethodPointerMono = (PassManagedInitializeMethodPointerDelegate)Marshal.GetDelegateForFunctionPointer(a, typeof(PassManagedInitializeMethodPointerDelegate));
		PassManagedEngineCallbackMethodPointersMono = (PassManagedCallbackMethodPointersDelegate)Marshal.GetDelegateForFunctionPointer(b, typeof(PassManagedCallbackMethodPointersDelegate));
	}

	public static void PassInitializationMethodPointersForDotNet(Delegate a, Delegate b)
	{
		PassManagedInitializeMethodPointerMono = a;
		PassManagedEngineCallbackMethodPointersMono = b;
	}

	public static void Start(IEnumerable<IManagedComponent> components)
	{
		_components.AddRange(components);
		Common.SetInvariantCulture();
		AppDomain.CurrentDomain.AppendPrivatePath(ManagedDllFolder.Name);
		AssemblyLoader.Initialize();
		_initializer = Initialize;
		PassManagedInitializeMethodPointer(_initializer);
		for (int i = 0; i < _components.Count; i++)
		{
			_components[i].OnStart();
		}
	}

	[MonoPInvokeCallback(typeof(ManagedInitializeMethod))]
	private static void Initialize()
	{
		Common.SetInvariantCulture();
		List<Type> typesSafe = AssemblyLoader.LoadFrom(ManagedCallbacksDll).GetTypesSafe();
		Type type = null;
		foreach (Type item in typesSafe)
		{
			if (item.GetInterfaces().Contains(typeof(ICallbackManager)))
			{
				type = item;
				break;
			}
		}
		_callbackManager = type.GetConstructor(new Type[0]).Invoke(new object[0]) as ICallbackManager;
		_callbackManager.Initialize();
		Delegate[] delegates = _callbackManager.GetDelegates();
		for (int i = 0; i < delegates.Length; i++)
		{
			try
			{
				PassManagedEngineCallbackMethodPointers(delegates[i]);
			}
			catch (Exception ex)
			{
				PassManagedEngineCallbackMethodPointers(null);
				Console.WriteLine(string.Concat(ex, " ", i));
			}
		}
		LibraryApplicationInterface.SetObjects(_callbackManager.GetScriptingInterfaceObjects());
	}

	[LibraryCallback]
	internal static void CheckSharedStructureSizes()
	{
		_callbackManager.CheckSharedStructureSizes();
	}

	[LibraryCallback]
	internal static void SetClosing()
	{
		Closing = true;
	}

	[LibraryCallback]
	internal static void PreFinalize()
	{
		Closing = true;
		_moduleTypes = null;
		ManagedObjectOwner.PreFinalizeManagedObjects();
		Common.MemoryCleanupGC();
	}

	[LibraryCallback]
	internal static void OnFinalize()
	{
		ManagedObject.FinalizeManagedObjects();
		Common.MemoryCleanupGC();
		ManagedObjectOwner.LogFinalize();
	}

	[LibraryCallback]
	internal static void ApplicationTick(float dt)
	{
		ManagedObject.HandleManagedObjects();
		DotNetObject.HandleDotNetObjects();
		NativeObject.HandleNativeObjects();
		ManagedObjectOwner.GarbageCollect();
		NativeTelemetryManager.Update();
		for (int i = 0; i < _components.Count; i++)
		{
			_components[i].OnApplicationTick(dt);
		}
	}

	[LibraryCallback]
	internal static void ApplicationTickLight(float dt)
	{
		DotNetObject.HandleDotNetObjects();
		NativeObject.HandleNativeObjects();
		NativeTelemetryManager.Update();
		for (int i = 0; i < _components.Count; i++)
		{
			_components[i].OnApplicationTick(dt);
		}
	}

	[LibraryCallback]
	internal static bool CheckClassNameIsValid(string className)
	{
		return _moduleTypes.ContainsKey(className);
	}

	[LibraryCallback]
	internal static int GetStringArrayLength(string[] array)
	{
		return array.Length;
	}

	[LibraryCallback]
	internal static string[] GetClassFields(string className, bool recursive, bool includeInternal, bool includeProtected, bool includePrivate)
	{
		List<string> list = new List<string>();
		if (_moduleTypes.TryGetValue(className, out var value))
		{
			FieldInfo[] fields = value.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			for (int i = 0; i < fields.Length; i++)
			{
				FieldInfo fieldInfo = fields[i];
				if (false || fieldInfo.IsPublic || (includePrivate && fieldInfo.IsPrivate) || (includeProtected && fieldInfo.IsFamily) || (includeInternal && fieldInfo.IsAssembly))
				{
					list.Add(fields[i].Name);
				}
			}
		}
		return list.ToArray();
	}

	[LibraryCallback]
	internal static ManagedObject CreateObjectClassInstanceWithPointer(string className, IntPtr pointer)
	{
		ConstructorInfo constructor = _moduleTypes[className].GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Type[1] { typeof(IntPtr) }, null);
		if (constructor != null)
		{
			object obj = constructor.Invoke(new object[1] { pointer });
			if (obj != null)
			{
				return obj as ManagedObject;
			}
		}
		return null;
	}

	internal static string GetClassNamesAux(Type type)
	{
		string text = "";
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		foreach (Assembly assembly in assemblies)
		{
			if (assembly.GlobalAssemblyCache)
			{
				continue;
			}
			try
			{
				string[] array = Array.ConvertAll(Array.FindAll(assembly.GetTypes(), (Type t) => (t.Equals(type) || t.IsSubclassOf(type)) && !t.IsAbstract), (Type t) => t.Name);
				if (array.Length != 0)
				{
					if (text != "")
					{
						text += " ";
					}
					text += string.Join(" ", array);
				}
			}
			catch (ReflectionTypeLoadException ex)
			{
				TaleWorlds.Library.Debug.Print(ex.Message + " " + ex.GetType());
				foreach (object value in ex.Data.Values)
				{
					TaleWorlds.Library.Debug.Print(value.ToString());
				}
			}
		}
		return text;
	}

	[LibraryCallback]
	internal static ManagedObject CreateObjectClassInstanceWithInteger(string className, int value)
	{
		ConstructorInfo constructor = _moduleTypes[className].GetConstructor(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Type[1] { typeof(int) }, null);
		if (constructor != null)
		{
			object obj = constructor.Invoke(new object[1] { value });
			if (obj != null)
			{
				return obj as ManagedObject;
			}
		}
		return null;
	}

	[LibraryCallback]
	internal static void SetCurrentStringReturnValue(IntPtr pointer)
	{
		ReturnValueFromEngine = Marshal.PtrToStringAnsi(pointer);
	}

	[LibraryCallback]
	internal static void SetCurrentStringReturnValueAsUnicode(IntPtr pointer)
	{
		ReturnValueFromEngine = Marshal.PtrToStringAnsi(pointer);
		byte[] bytes = Encoding.Default.GetBytes(ReturnValueFromEngine);
		byte[] bytes2 = Encoding.Convert(Encoding.UTF8, Encoding.Unicode, bytes);
		ReturnValueFromEngine = Encoding.Unicode.GetString(bytes2);
	}

	[LibraryCallback]
	internal static string GetObjectClassName(string className)
	{
		if (_moduleTypes.TryGetValue(className, out var value))
		{
			return value.Name;
		}
		return "unknown";
	}

	[LibraryCallback]
	internal static void EngineApiMethodInterfaceInitializer(int id, IntPtr pointer)
	{
		_engineApiPointers.Add(id, pointer);
	}

	[LibraryCallback]
	internal static void FillEngineApiPointers()
	{
		foreach (KeyValuePair<int, IntPtr> engineApiPointer in _engineApiPointers)
		{
			try
			{
				_callbackManager.SetFunctionPointer(engineApiPointer.Key, engineApiPointer.Value);
			}
			catch (Exception ex)
			{
				Console.WriteLine("error: " + engineApiPointer.Key + " " + ex);
			}
		}
	}

	[LibraryCallback]
	internal static long GetMemoryUsage()
	{
		return GC.GetTotalMemory(forceFullCollection: false);
	}

	[LibraryCallback]
	internal static void PassCustomCallbackMethodPointers(string name, IntPtr initalizer)
	{
		Delegate delegateForFunctionPointer = Marshal.GetDelegateForFunctionPointer(initalizer, typeof(InitializerDelegate));
		for (int i = 0; i < _components.Count; i++)
		{
			_components[i].OnCustomCallbackMethodPassed(name, delegateForFunctionPointer);
		}
	}

	[LibraryCallback]
	internal static string CallCommandlineFunction(string functionName, string arguments)
	{
		bool found;
		return CommandLineFunctionality.CallFunction(functionName, arguments, out found);
	}

	public static void InitializeTypes(Dictionary<string, Type> types)
	{
		_moduleTypes = types;
		foreach (KeyValuePair<string, Type> type in types)
		{
			Dictionary<string, FieldInfo> dictionary = new Dictionary<string, FieldInfo>();
			Dictionary<string, FieldInfo> dictionary2 = new Dictionary<string, FieldInfo>();
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
			FieldInfo[] fields = type.Value.GetFields(bindingFlags);
			foreach (FieldInfo fieldInfo in fields)
			{
				string name = fieldInfo.Name;
				object[] customAttributesSafe = fieldInfo.GetCustomAttributesSafe(typeof(EditableScriptComponentVariable), inherit: true);
				bool flag = false;
				if (customAttributesSafe.Length != 0)
				{
					flag = ((EditableScriptComponentVariable)customAttributesSafe[0]).Visible;
				}
				else if (!fieldInfo.IsPrivate && !fieldInfo.IsFamily)
				{
					flag = true;
				}
				if (flag)
				{
					dictionary2.Add(name, fieldInfo);
				}
				dictionary.Add(name, fieldInfo);
			}
			_fieldsOfScriptsCached.Add(type.Key, dictionary);
			_editableFieldsOfScriptsCached.Add(type.Key, dictionary2);
			bindingFlags |= BindingFlags.CreateInstance;
			ConstructorInfo constructor = type.Value.GetConstructor(bindingFlags, null, new Type[0], null);
			_constructorsOfScriptsCached.Add(type.Key, constructor);
		}
	}

	public static void AddTypes(Dictionary<string, Type> types)
	{
		_moduleTypes = _moduleTypes.Union(types).ToDictionary((KeyValuePair<string, Type> k) => k.Key, (KeyValuePair<string, Type> v) => v.Value);
		foreach (KeyValuePair<string, Type> type in types)
		{
			Dictionary<string, FieldInfo> dictionary = new Dictionary<string, FieldInfo>();
			Dictionary<string, FieldInfo> dictionary2 = new Dictionary<string, FieldInfo>();
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
			FieldInfo[] fields = type.Value.GetFields(bindingFlags);
			foreach (FieldInfo fieldInfo in fields)
			{
				string name = fieldInfo.Name;
				object[] customAttributesSafe = fieldInfo.GetCustomAttributesSafe(typeof(EditableScriptComponentVariable), inherit: true);
				bool flag = false;
				if (customAttributesSafe.Length != 0)
				{
					flag = ((EditableScriptComponentVariable)customAttributesSafe[0]).Visible;
				}
				else if (!fieldInfo.IsPrivate && !fieldInfo.IsFamily)
				{
					flag = true;
				}
				if (flag)
				{
					dictionary2.Add(name, fieldInfo);
				}
				dictionary.Add(name, fieldInfo);
			}
			_fieldsOfScriptsCached.Add(type.Key, dictionary);
			_editableFieldsOfScriptsCached.Add(type.Key, dictionary2);
			bindingFlags |= BindingFlags.CreateInstance;
			ConstructorInfo constructor = type.Value.GetConstructor(bindingFlags, null, new Type[0], null);
			_constructorsOfScriptsCached.Add(type.Key, constructor);
		}
	}

	public static void AddConstructorDelegateOfClass<T>()
	{
		Type typeFromHandle = typeof(T);
		string name = typeFromHandle.Name;
		if (!_constructorDelegatesOfScriptsCached.ContainsKey(name))
		{
			_constructorDelegatesOfScriptsCached[name] = Expression.Lambda<Func<T>>(Expression.New(typeFromHandle), Array.Empty<ParameterExpression>()).Compile();
		}
	}

	public static void AddConstructorDelegateOfWeakReferenceClass<T>()
	{
		Type typeFromHandle = typeof(T);
		if (!_constructorDelegatesOfWeakReferencesCached.ContainsKey(typeFromHandle))
		{
			_constructorDelegatesOfWeakReferencesCached[typeFromHandle] = Expression.Lambda<Func<T>>(Expression.New(typeFromHandle), Array.Empty<ParameterExpression>()).Compile();
		}
	}

	private static void PassManagedInitializeMethodPointer(Delegate initializer)
	{
		PassManagedInitializeMethodPointerMono?.DynamicInvoke(initializer);
	}

	private static void PassManagedEngineCallbackMethodPointers(Delegate methodDelegate)
	{
		PassManagedEngineCallbackMethodPointersMono?.DynamicInvoke(methodDelegate);
	}

	[LibraryCallback]
	internal static void LoadManagedComponent(string assemblyName, string managedInterface)
	{
		IManagedComponent managedComponent = (IManagedComponent)Activator.CreateInstance(AssemblyLoader.LoadFrom(ManagedDllFolder.Name + assemblyName + ".dll").GetType(managedInterface));
		_components.Add(managedComponent);
		managedComponent.OnStart();
	}

	internal static Dictionary<string, FieldInfo> GetEditableFieldsOfClass(string className)
	{
		_editableFieldsOfScriptsCached.TryGetValue(className, out var value);
		return value;
	}

	internal static FieldInfo GetFieldOfClass(string className, string fieldName)
	{
		if (_fieldsOfScriptsCached.TryGetValue(className, out var value))
		{
			value.TryGetValue(fieldName, out var value2);
			return value2;
		}
		return null;
	}

	internal static ConstructorInfo GetConstructorOfClass(string className)
	{
		_constructorsOfScriptsCached.TryGetValue(className, out var value);
		return value;
	}

	internal static Delegate GetConstructorDelegateOfClass(string className)
	{
		_constructorDelegatesOfScriptsCached.TryGetValue(className, out var value);
		return value;
	}

	internal static Delegate GetConstructorDelegateOfWeakReferenceClass(Type classType)
	{
		return _constructorDelegatesOfWeakReferencesCached[classType];
	}

	[LibraryCallback]
	internal static bool IsClassFieldExists(string className, string fieldName)
	{
		return GetFieldOfClass(className, fieldName) != null;
	}

	[LibraryCallback]
	internal static string GetEnumNamesOfField(string className, string fieldName)
	{
		string text = GetFieldOfClass(className, fieldName).FieldType.FullName;
		string text2 = text.Substring(0, text.IndexOf('.'));
		if (text2 != null && text2 != "" && text2 != Assembly.GetExecutingAssembly().GetName().Name)
		{
			text = text + ", " + text2;
		}
		Type type = Type.GetType(text);
		if (type == null)
		{
			int startIndex = text.IndexOf(',');
			text = text.Remove(startIndex);
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			for (int i = 0; i < assemblies.Length; i++)
			{
				type = assemblies[i].GetType(text);
				if (type != null)
				{
					break;
				}
			}
		}
		type.GetEnumValues();
		string[] enumNames = type.GetEnumNames();
		return string.Join(" ", enumNames);
	}

	[CommandLineFunctionality.CommandLineArgumentFunction("show_version", "dotnet")]
	public static string ShowDotNetVersion(List<string> strings)
	{
		string frameworkDescription = RuntimeInformation.FrameworkDescription;
		TaleWorlds.Library.Debug.Print("Version:" + frameworkDescription);
		return frameworkDescription;
	}
}
